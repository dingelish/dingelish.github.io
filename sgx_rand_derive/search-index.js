var N = null;var searchIndex = {};
searchIndex["quote"]={"doc":"Quasi-quoting without a Syntex dependency, intended for use with Macros 1.1.","items":[[3,"Tokens","quote","Tokens produced by a `quote!(...)` invocation.",N,N],[3,"ByteStr","","Wrap a `&str` so it interpolates as a byte-string: `b\"abc\"`.",N,N],[12,"0","","",0,N],[3,"Hex","","Wrap an integer so it interpolates as a hexadecimal.",N,N],[12,"0","","",1,N],[3,"Ident","","An identifier that should be interpolated without quotes.",N,N],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"clone","","",2,[[["self"]],["tokens"]]],[11,"eq","","",2,[[["self"],["tokens"]],["bool"]]],[11,"ne","","",2,[[["self"],["tokens"]],["bool"]]],[11,"new","","Empty tokens.",2,[[],["self"]]],[11,"append","","For use by `ToTokens` implementations.",2,[[["self"],["t"]]]],[11,"append_all","","For use by `ToTokens` implementations.",2,[[["self"],["i"]]]],[11,"append_separated","","For use by `ToTokens` implementations.",2,[[["self"],["i"],["s"]]]],[11,"append_terminated","","For use by `ToTokens` implementations.",2,[[["self"],["i"],["s"]]]],[11,"as_str","","",2,[[["self"]],["str"]]],[11,"into_string","","",2,[[["self"]],["string"]]],[11,"parse","","",2,[[["self"]],["result"]]],[11,"default","","",2,[[],["self"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result",["error"]]]],[11,"as_ref","","",2,[[["self"]],["str"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"to_tokens","","",0,[[["self"],["tokens"]]]],[11,"to_tokens","","",2,[[["self"],["tokens"]]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"to_tokens","","",1,[[["self"],["tokens"]]]],[11,"to_tokens","","",1,[[["self"],["tokens"]]]],[11,"to_tokens","","",1,[[["self"],["tokens"]]]],[11,"to_tokens","","",1,[[["self"],["tokens"]]]],[11,"to_tokens","","",1,[[["self"],["tokens"]]]],[11,"to_tokens","","",1,[[["self"],["tokens"]]]],[11,"to_tokens","","",1,[[["self"],["tokens"]]]],[11,"to_tokens","","",1,[[["self"],["tokens"]]]],[11,"to_tokens","","",1,[[["self"],["tokens"]]]],[11,"to_tokens","","",1,[[["self"],["tokens"]]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"clone","","",3,[[["self"]],["ident"]]],[11,"hash","","",3,N],[11,"new","","",3,[[["t"]],["self"]]],[11,"from","","",3,[[["str"]],["self"]]],[11,"from","","",3,[[["cow",["str"]]],["self"]]],[11,"from","","",3,[[["string"]],["self"]]],[11,"as_ref","","",3,[[["self"]],["str"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result",["error"]]]],[11,"eq","","",3,[[["self"],["t"]],["bool"]]],[11,"to_tokens","","",3,[[["self"],["tokens"]]]],[8,"ToTokens","","Types that can be interpolated inside a `quote!(...)` invocation.",N,N],[10,"to_tokens","","Write `self` to the given `Tokens`.",4,[[["self"],["tokens"]]]],[14,"quote","","The whole point.",N,N]],"paths":[[3,"ByteStr"],[3,"Hex"],[3,"Tokens"],[3,"Ident"],[8,"ToTokens"]]};
searchIndex["sgx_rand_derive"]={"doc":"Support for `#[derive(Rand)]`","items":[[5,"rand_derive","sgx_rand_derive","",N,[[["tokenstream"]],["tokenstream"]]]],"paths":[]};
searchIndex["syn"]={"doc":"","items":[[3,"Attribute","syn","Doc-comments are promoted to attributes that have `is_sugared_doc` = true",N,N],[12,"style","","",0,N],[12,"value","","",0,N],[12,"is_sugared_doc","","",0,N],[3,"Field","","A field of a struct or enum variant.",N,N],[12,"ident","","Name of the field, if any.",1,N],[12,"vis","","Visibility of the field.",1,N],[12,"attrs","","Attributes tagged on the field.",1,N],[12,"ty","","Type of the field.",1,N],[3,"Variant","","An enum variant.",N,N],[12,"ident","","Name of the variant.",2,N],[12,"attrs","","Attributes tagged on the variant.",2,N],[12,"data","","Type of variant.",2,N],[12,"discriminant","","Explicit discriminant, e.g. `Foo = 1`",2,N],[3,"Generics","","Represents lifetimes and type parameters attached to a declaration of a function, enum, trait, etc.",N,N],[12,"lifetimes","","",3,N],[12,"ty_params","","",3,N],[12,"where_clause","","",3,N],[3,"Lifetime","","",N,N],[12,"ident","","",4,N],[3,"LifetimeDef","","A lifetime definition, e.g. `'a: 'b+'c+'d`",N,N],[12,"attrs","","",5,N],[12,"lifetime","","",5,N],[12,"bounds","","",5,N],[3,"TyParam","","A generic type parameter, e.g. `T: Into<String>`.",N,N],[12,"attrs","","",6,N],[12,"ident","","",6,N],[12,"bounds","","",6,N],[12,"default","","",6,N],[3,"WhereBoundPredicate","","A type bound.",N,N],[12,"bound_lifetimes","","Any lifetimes from a `for` binding",7,N],[12,"bounded_ty","","The type being bounded",7,N],[12,"bounds","","Trait and lifetime bounds (`Clone+Send+'static`)",7,N],[3,"WhereClause","","A `where` clause in a definition",N,N],[12,"predicates","","",8,N],[3,"WhereEqPredicate","","An equality predicate (unsupported).",N,N],[12,"lhs_ty","","",9,N],[12,"rhs_ty","","",9,N],[3,"WhereRegionPredicate","","A lifetime predicate.",N,N],[12,"lifetime","","",10,N],[12,"bounds","","",10,N],[3,"ImplGenerics","","Returned by `Generics::split_for_impl`.",N,N],[3,"Turbofish","","Returned by `TyGenerics::as_turbofish`.",N,N],[3,"TyGenerics","","Returned by `Generics::split_for_impl`.",N,N],[3,"Ident","","",N,N],[3,"ByteStrLit","","",N,N],[12,"value","","",11,N],[12,"style","","",11,N],[3,"FloatLit","","",N,N],[12,"value","","",12,N],[12,"suffix","","",12,N],[3,"IntLit","","",N,N],[12,"value","","",13,N],[12,"suffix","","",13,N],[3,"StrLit","","",N,N],[12,"value","","",14,N],[12,"style","","",14,N],[3,"Delimited","","",N,N],[12,"delim","","The type of delimiter",15,N],[12,"tts","","The delimited sequence of token trees",15,N],[3,"Mac","","Represents a macro invocation. The Path indicates which macro is being invoked, and the vector of token-trees contains the source of the macro invocation.",N,N],[12,"path","","",16,N],[12,"tts","","",16,N],[3,"DeriveInput","","Struct or enum sent to a `proc_macro_derive` macro.",N,N],[12,"ident","","Name of the struct or enum.",17,N],[12,"vis","","Visibility of the struct or enum.",17,N],[12,"attrs","","Attributes tagged on the whole struct or enum.",17,N],[12,"generics","","Generics required to complete the definition.",17,N],[12,"body","","Data within the struct or enum.",17,N],[3,"AngleBracketedParameterData","","A path like `Foo<'a, T>`",N,N],[12,"lifetimes","","The lifetime parameters for this path segment.",18,N],[12,"types","","The type parameters for this path segment, if present.",18,N],[12,"bindings","","Bindings (equality constraints) on associated types, if present.",18,N],[3,"BareFnArg","","An argument in a function type.",N,N],[12,"name","","",19,N],[12,"ty","","",19,N],[3,"BareFnTy","","",N,N],[12,"unsafety","","",20,N],[12,"abi","","",20,N],[12,"lifetimes","","",20,N],[12,"inputs","","",20,N],[12,"output","","",20,N],[12,"variadic","","",20,N],[3,"MutTy","","",N,N],[12,"ty","","",21,N],[12,"mutability","","",21,N],[3,"ParenthesizedParameterData","","A path like `Foo(A,B) -> C`",N,N],[12,"inputs","","`(A, B)`",22,N],[12,"output","","`C`",22,N],[3,"Path","","A \"Path\" is essentially Rust's notion of a name.",N,N],[12,"global","","A `::foo` path, is relative to the crate root rather than current module (like paths in an import).",23,N],[12,"segments","","The segments in the path: the things separated by `::`.",23,N],[3,"PathSegment","","A segment of a path: an identifier, an optional lifetime, and a set of types.",N,N],[12,"ident","","The identifier portion of this path segment.",24,N],[12,"parameters","","Type/lifetime parameters attached to this path. They come in two flavors: `Path<A,B,C>` and `Path(A,B) -> C`. Note that this is more than just simple syntactic sugar; the use of parens affects the region binding rules, so we preserve the distinction.",24,N],[3,"PolyTraitRef","","",N,N],[12,"bound_lifetimes","","The `'a` in `<'a> Foo<&'a T>`",25,N],[12,"trait_ref","","The `Foo<&'a T>` in `<'a> Foo<&'a T>`",25,N],[3,"QSelf","","The explicit Self type in a \"qualified path\". The actual path, including the trait and the associated item, is stored separately. `position` represents the index of the associated item qualified with this Self type.",N,N],[12,"ty","","",26,N],[12,"position","","",26,N],[3,"TypeBinding","","Bind a type to an associated type: `A=Foo`.",N,N],[12,"ident","","",27,N],[12,"ty","","",27,N],[4,"AttrStyle","","Distinguishes between Attributes that decorate items and Attributes that are contained as statements within items. These two cases need to be distinguished for pretty-printing.",N,N],[13,"Outer","","Attribute of the form `#![...]`.",28,N],[13,"Inner","","Attribute of the form `#[...]`.",28,N],[4,"MetaItem","","A compile-time attribute item.",N,N],[13,"Word","","Word meta item.",29,N],[13,"List","","List meta item.",29,N],[13,"NameValue","","Name-value meta item.",29,N],[4,"NestedMetaItem","","Possible values inside of compile-time attribute lists.",N,N],[13,"MetaItem","","A full `MetaItem`.",30,N],[13,"Literal","","A Rust literal.",30,N],[4,"ConstExpr","","",N,N],[13,"Call","","A function call",31,N],[13,"Binary","","A binary operation (For example: `a + b`, `a * b`)",31,N],[13,"Unary","","A unary operation (For example: `!x`, `*x`)",31,N],[13,"Lit","","A literal (For example: `1`, `\"foo\"`)",31,N],[13,"Cast","","A cast (`foo as f64`)",31,N],[13,"Path","","Variable reference, possibly containing `::` and/or type parameters, e.g. foo::bar::.",31,N],[13,"Index","","An indexing operation (`foo[2]`)",31,N],[13,"Paren","","No-op: used solely so we can pretty-print faithfully",31,N],[13,"Other","","If compiling with full support for expression syntax, any expression is allowed",31,N],[4,"VariantData","","Data stored within an enum variant or struct.",N,N],[13,"Struct","","Struct variant, e.g. `Point { x: f64, y: f64 }`.",32,N],[13,"Tuple","","Tuple variant, e.g. `Some(T)`.",32,N],[13,"Unit","","Unit variant, e.g. `None`.",32,N],[4,"Visibility","","Visibility level of an item.",N,N],[13,"Public","","Public, i.e. `pub`.",33,N],[13,"Crate","","Crate-visible, i.e. `pub(crate)`.",33,N],[13,"Restricted","","Restricted, e.g. `pub(some::module)`.",33,N],[13,"Inherited","","Inherited, i.e. private.",33,N],[4,"TraitBoundModifier","","A modifier on a bound, currently this is only used for `?Sized`, where the modifier is `Maybe`. Negative bounds should also be handled here.",N,N],[13,"None","","",34,N],[13,"Maybe","","",34,N],[4,"TyParamBound","","The AST represents all type param bounds as types. `typeck::collect::compute_bounds` matches these against the \"special\" built-in traits (see `middle::lang_items`) and detects Copy, Send and Sync.",N,N],[13,"Trait","","",35,N],[13,"Region","","",35,N],[4,"WherePredicate","","A single predicate in a `where` clause",N,N],[13,"BoundPredicate","","A type binding, e.g. `for<'c> Foo: Send+Clone+'c`",36,N],[13,"RegionPredicate","","A lifetime predicate, e.g. `'a: 'b+'c`",36,N],[13,"EqPredicate","","An equality predicate (unsupported)",36,N],[4,"FloatTy","","",N,N],[13,"F32","","",37,N],[13,"F64","","",37,N],[13,"Unsuffixed","","",37,N],[4,"IntTy","","",N,N],[13,"Isize","","",38,N],[13,"I8","","",38,N],[13,"I16","","",38,N],[13,"I32","","",38,N],[13,"I64","","",38,N],[13,"Usize","","",38,N],[13,"U8","","",38,N],[13,"U16","","",38,N],[13,"U32","","",38,N],[13,"U64","","",38,N],[13,"Unsuffixed","","",38,N],[4,"Lit","","Literal kind.",N,N],[13,"Str","","A string literal (`\"foo\"`)",39,N],[13,"ByteStr","","A byte string (`b\"foo\"`)",39,N],[13,"Byte","","A byte char (`b'f'`)",39,N],[13,"Char","","A character literal (`'a'`)",39,N],[13,"Int","","An integer literal (`1`)",39,N],[13,"Float","","A float literal (`1f64` or `1E10f64` or `1.0E10`)",39,N],[13,"Bool","","A boolean literal",39,N],[4,"StrStyle","","",N,N],[13,"Cooked","","A regular string, like `\"foo\"`",40,N],[13,"Raw","","A raw string, like `r##\"foo\"##`",40,N],[4,"BinOpToken","","",N,N],[13,"Plus","","",41,N],[13,"Minus","","",41,N],[13,"Star","","",41,N],[13,"Slash","","",41,N],[13,"Percent","","",41,N],[13,"Caret","","",41,N],[13,"And","","",41,N],[13,"Or","","",41,N],[13,"Shl","","",41,N],[13,"Shr","","",41,N],[4,"DelimToken","","A delimiter token",N,N],[13,"Paren","","A round parenthesis: `(` or `)`",42,N],[13,"Bracket","","A square bracket: `[` or `]`",42,N],[13,"Brace","","A curly brace: `{` or `}`",42,N],[4,"Token","","",N,N],[13,"Eq","","",43,N],[13,"Lt","","",43,N],[13,"Le","","",43,N],[13,"EqEq","","",43,N],[13,"Ne","","",43,N],[13,"Ge","","",43,N],[13,"Gt","","",43,N],[13,"AndAnd","","",43,N],[13,"OrOr","","",43,N],[13,"Not","","",43,N],[13,"Tilde","","",43,N],[13,"BinOp","","",43,N],[13,"BinOpEq","","",43,N],[13,"At","","",43,N],[13,"Dot","","",43,N],[13,"DotDot","","",43,N],[13,"DotDotDot","","",43,N],[13,"Comma","","",43,N],[13,"Semi","","",43,N],[13,"Colon","","",43,N],[13,"ModSep","","",43,N],[13,"RArrow","","",43,N],[13,"LArrow","","",43,N],[13,"FatArrow","","",43,N],[13,"Pound","","",43,N],[13,"Dollar","","",43,N],[13,"Question","","",43,N],[13,"Literal","","",43,N],[13,"Ident","","",43,N],[13,"Underscore","","",43,N],[13,"Lifetime","","",43,N],[13,"DocComment","","",43,N],[4,"TokenTree","","When the main rust parser encounters a syntax-extension invocation, it parses the arguments to the invocation as a token-tree. This is a very loose structure, such that all sorts of different AST-fragments can be passed to syntax extensions using a uniform type.",N,N],[13,"Token","","A single token",44,N],[13,"Delimited","","A delimited sequence of token trees",44,N],[4,"Body","","Body of a derived struct or enum.",N,N],[13,"Enum","","It's an enum.",45,N],[13,"Struct","","It's a struct.",45,N],[4,"BinOp","","",N,N],[13,"Add","","The `+` operator (addition)",46,N],[13,"Sub","","The `-` operator (subtraction)",46,N],[13,"Mul","","The `*` operator (multiplication)",46,N],[13,"Div","","The `/` operator (division)",46,N],[13,"Rem","","The `%` operator (modulus)",46,N],[13,"And","","The `&&` operator (logical and)",46,N],[13,"Or","","The `||` operator (logical or)",46,N],[13,"BitXor","","The `^` operator (bitwise xor)",46,N],[13,"BitAnd","","The `&` operator (bitwise and)",46,N],[13,"BitOr","","The `|` operator (bitwise or)",46,N],[13,"Shl","","The `<<` operator (shift left)",46,N],[13,"Shr","","The `>>` operator (shift right)",46,N],[13,"Eq","","The `==` operator (equality)",46,N],[13,"Lt","","The `<` operator (less than)",46,N],[13,"Le","","The `<=` operator (less than or equal to)",46,N],[13,"Ne","","The `!=` operator (not equal to)",46,N],[13,"Ge","","The `>=` operator (greater than or equal to)",46,N],[13,"Gt","","The `>` operator (greater than)",46,N],[4,"UnOp","","",N,N],[13,"Deref","","The `*` operator for dereferencing",47,N],[13,"Not","","The `!` operator for logical inversion",47,N],[13,"Neg","","The `-` operator for negation",47,N],[4,"Abi","","",N,N],[13,"Named","","",48,N],[13,"Rust","","",48,N],[4,"FunctionRetTy","","",N,N],[13,"Default","","Return type is not specified.",49,N],[13,"Ty","","Everything else",49,N],[4,"Mutability","","",N,N],[13,"Mutable","","",50,N],[13,"Immutable","","",50,N],[4,"PathParameters","","Parameters of a path segment.",N,N],[13,"AngleBracketed","","The `<'a, A, B, C>` in `foo::bar::baz::<'a, A, B, C>`",51,N],[13,"Parenthesized","","The `(A, B)` and `C` in `Foo(A, B) -> C`",51,N],[4,"Ty","","The different kinds of types recognized by the compiler",N,N],[13,"Slice","","A variable-length array (`[T]`)",52,N],[13,"Array","","A fixed length array (`[T; n]`)",52,N],[13,"Ptr","","A raw pointer (`*const T` or `*mut T`)",52,N],[13,"Rptr","","A reference (`&'a T` or `&'a mut T`)",52,N],[13,"BareFn","","A bare function (e.g. `fn(usize) -> bool`)",52,N],[13,"Never","","The never type (`!`)",52,N],[13,"Tup","","A tuple (`(A, B, C, D, ...)`)",52,N],[13,"Path","","A path (`module::module::...::Type`), optionally \"qualified\", e.g. `<Vec<T> as SomeTrait>::SomeType`.",52,N],[13,"TraitObject","","A trait object type `Bound1 + Bound2 + Bound3` where `Bound` is a trait or a lifetime.",52,N],[13,"ImplTrait","","An `impl Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime.",52,N],[13,"Paren","","No-op; kept solely so that we can pretty-print faithfully",52,N],[13,"Infer","","TyKind::Infer means the type should be inferred instead of it having been specified. This can appear anywhere in a type.",52,N],[13,"Mac","","A macro in the type position.",52,N],[4,"Unsafety","","",N,N],[13,"Unsafe","","",53,N],[13,"Normal","","",53,N],[5,"parse_derive_input","","",N,[[["str"]],["result",["deriveinput","string"]]]],[5,"parse_type","","",N,[[["str"]],["result",["ty","string"]]]],[5,"parse_path","","",N,[[["str"]],["result",["path","string"]]]],[5,"parse_where_clause","","",N,[[["str"]],["result",["whereclause","string"]]]],[5,"parse_token_trees","","",N,[[["str"]],["result",["vec","string"]]]],[5,"parse_ident","","",N,[[["str"]],["result",["ident","string"]]]],[5,"parse_ty_param_bound","","",N,[[["str"]],["result",["typarambound","string"]]]],[5,"parse_outer_attr","","",N,[[["str"]],["result",["attribute","string"]]]],[11,"to_tokens","","",0,[[["self"],["tokens"]]]],[11,"to_tokens","","",29,[[["self"],["tokens"]]]],[11,"to_tokens","","",30,[[["self"],["tokens"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"clone","","",0,[[["self"]],["attribute"]]],[11,"eq","","",0,[[["self"],["attribute"]],["bool"]]],[11,"ne","","",0,[[["self"],["attribute"]],["bool"]]],[11,"hash","","",0,N],[11,"name","","",0,[[["self"]],["str"]]],[11,"fmt","","",28,[[["self"],["formatter"]],["result"]]],[11,"clone","","",28,[[["self"]],["attrstyle"]]],[11,"eq","","",28,[[["self"],["attrstyle"]],["bool"]]],[11,"hash","","",28,N],[11,"fmt","","",29,[[["self"],["formatter"]],["result"]]],[11,"clone","","",29,[[["self"]],["metaitem"]]],[11,"eq","","",29,[[["self"],["metaitem"]],["bool"]]],[11,"ne","","",29,[[["self"],["metaitem"]],["bool"]]],[11,"hash","","",29,N],[11,"name","","Name of the item.",29,[[["self"]],["str"]]],[11,"fmt","","",30,[[["self"],["formatter"]],["result"]]],[11,"clone","","",30,[[["self"]],["nestedmetaitem"]]],[11,"eq","","",30,[[["self"],["nestedmetaitem"]],["bool"]]],[11,"ne","","",30,[[["self"],["nestedmetaitem"]],["bool"]]],[11,"hash","","",30,N],[11,"to_tokens","","",31,[[["self"],["tokens"]]]],[11,"fmt","","",31,[[["self"],["formatter"]],["result"]]],[11,"clone","","",31,[[["self"]],["constexpr"]]],[11,"eq","","",31,[[["self"],["constexpr"]],["bool"]]],[11,"ne","","",31,[[["self"],["constexpr"]],["bool"]]],[11,"hash","","",31,N],[11,"to_tokens","","",2,[[["self"],["tokens"]]]],[11,"to_tokens","","",32,[[["self"],["tokens"]]]],[11,"to_tokens","","",1,[[["self"],["tokens"]]]],[11,"to_tokens","","",33,[[["self"],["tokens"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"clone","","",2,[[["self"]],["variant"]]],[11,"eq","","",2,[[["self"],["variant"]],["bool"]]],[11,"ne","","",2,[[["self"],["variant"]],["bool"]]],[11,"hash","","",2,N],[11,"fmt","","",32,[[["self"],["formatter"]],["result"]]],[11,"clone","","",32,[[["self"]],["variantdata"]]],[11,"eq","","",32,[[["self"],["variantdata"]],["bool"]]],[11,"ne","","",32,[[["self"],["variantdata"]],["bool"]]],[11,"hash","","",32,N],[11,"fields","","Slice containing the fields stored in the variant.",32,N],[11,"fields_mut","","Mutable slice containing the fields stored in the variant.",32,N],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"clone","","",1,[[["self"]],["field"]]],[11,"eq","","",1,[[["self"],["field"]],["bool"]]],[11,"ne","","",1,[[["self"],["field"]],["bool"]]],[11,"hash","","",1,N],[11,"fmt","","",33,[[["self"],["formatter"]],["result"]]],[11,"clone","","",33,[[["self"]],["visibility"]]],[11,"eq","","",33,[[["self"],["visibility"]],["bool"]]],[11,"ne","","",33,[[["self"],["visibility"]],["bool"]]],[11,"hash","","",33,N],[11,"to_tokens","","",3,[[["self"],["tokens"]]]],[11,"to_tokens","","",54,[[["self"],["tokens"]]]],[11,"to_tokens","","",55,[[["self"],["tokens"]]]],[11,"to_tokens","","",56,[[["self"],["tokens"]]]],[11,"to_tokens","","",4,[[["self"],["tokens"]]]],[11,"to_tokens","","",5,[[["self"],["tokens"]]]],[11,"to_tokens","","",6,[[["self"],["tokens"]]]],[11,"to_tokens","","",35,[[["self"],["tokens"]]]],[11,"to_tokens","","",8,[[["self"],["tokens"]]]],[11,"to_tokens","","",36,[[["self"],["tokens"]]]],[11,"to_tokens","","",7,[[["self"],["tokens"]]]],[11,"to_tokens","","",10,[[["self"],["tokens"]]]],[11,"to_tokens","","",9,[[["self"],["tokens"]]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"clone","","",3,[[["self"]],["generics"]]],[11,"eq","","",3,[[["self"],["generics"]],["bool"]]],[11,"ne","","",3,[[["self"],["generics"]],["bool"]]],[11,"default","","",3,[[],["generics"]]],[11,"hash","","",3,N],[11,"fmt","","",54,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",55,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",56,[[["self"],["formatter"]],["result"]]],[11,"split_for_impl","","Split a type's generics into the pieces required for impl'ing a trait for that type.",3,N],[11,"as_turbofish","","Turn a type's generics like `<X, Y>` into a turbofish like `::<X, Y>`.",55,[[["self"]],["turbofish"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"clone","","",4,[[["self"]],["lifetime"]]],[11,"eq","","",4,[[["self"],["lifetime"]],["bool"]]],[11,"ne","","",4,[[["self"],["lifetime"]],["bool"]]],[11,"hash","","",4,N],[11,"cmp","","",4,[[["self"],["lifetime"]],["ordering"]]],[11,"partial_cmp","","",4,[[["self"],["lifetime"]],["option",["ordering"]]]],[11,"lt","","",4,[[["self"],["lifetime"]],["bool"]]],[11,"le","","",4,[[["self"],["lifetime"]],["bool"]]],[11,"gt","","",4,[[["self"],["lifetime"]],["bool"]]],[11,"ge","","",4,[[["self"],["lifetime"]],["bool"]]],[11,"new","","",4,[[["t"]],["self"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"clone","","",5,[[["self"]],["lifetimedef"]]],[11,"eq","","",5,[[["self"],["lifetimedef"]],["bool"]]],[11,"ne","","",5,[[["self"],["lifetimedef"]],["bool"]]],[11,"hash","","",5,N],[11,"new","","",5,[[["t"]],["self"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"clone","","",6,[[["self"]],["typaram"]]],[11,"eq","","",6,[[["self"],["typaram"]],["bool"]]],[11,"ne","","",6,[[["self"],["typaram"]],["bool"]]],[11,"hash","","",6,N],[11,"from","","",6,[[["ident"]],["self"]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result"]]],[11,"clone","","",35,[[["self"]],["typarambound"]]],[11,"eq","","",35,[[["self"],["typarambound"]],["bool"]]],[11,"ne","","",35,[[["self"],["typarambound"]],["bool"]]],[11,"hash","","",35,N],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"clone","","",34,[[["self"]],["traitboundmodifier"]]],[11,"eq","","",34,[[["self"],["traitboundmodifier"]],["bool"]]],[11,"hash","","",34,N],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"clone","","",8,[[["self"]],["whereclause"]]],[11,"eq","","",8,[[["self"],["whereclause"]],["bool"]]],[11,"ne","","",8,[[["self"],["whereclause"]],["bool"]]],[11,"default","","",8,[[],["whereclause"]]],[11,"hash","","",8,N],[11,"none","","",8,[[],["self"]]],[11,"fmt","","",36,[[["self"],["formatter"]],["result"]]],[11,"clone","","",36,[[["self"]],["wherepredicate"]]],[11,"eq","","",36,[[["self"],["wherepredicate"]],["bool"]]],[11,"ne","","",36,[[["self"],["wherepredicate"]],["bool"]]],[11,"hash","","",36,N],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"clone","","",7,[[["self"]],["whereboundpredicate"]]],[11,"eq","","",7,[[["self"],["whereboundpredicate"]],["bool"]]],[11,"ne","","",7,[[["self"],["whereboundpredicate"]],["bool"]]],[11,"hash","","",7,N],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"clone","","",10,[[["self"]],["whereregionpredicate"]]],[11,"eq","","",10,[[["self"],["whereregionpredicate"]],["bool"]]],[11,"ne","","",10,[[["self"],["whereregionpredicate"]],["bool"]]],[11,"hash","","",10,N],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"clone","","",9,[[["self"]],["whereeqpredicate"]]],[11,"eq","","",9,[[["self"],["whereeqpredicate"]],["bool"]]],[11,"ne","","",9,[[["self"],["whereeqpredicate"]],["bool"]]],[11,"hash","","",9,N],[11,"to_tokens","","",57,[[["self"],["tokens"]]]],[11,"fmt","","",57,[[["self"],["formatter"]],["result"]]],[11,"clone","","",57,[[["self"]],["ident"]]],[11,"hash","","",57,N],[11,"cmp","","",57,[[["self"],["ident"]],["ordering"]]],[11,"partial_cmp","","",57,[[["self"],["ident"]],["option",["ordering"]]]],[11,"lt","","",57,[[["self"],["ident"]],["bool"]]],[11,"le","","",57,[[["self"],["ident"]],["bool"]]],[11,"gt","","",57,[[["self"],["ident"]],["bool"]]],[11,"ge","","",57,[[["self"],["ident"]],["bool"]]],[11,"new","","",57,[[["t"]],["self"]]],[11,"from","","",57,[[["str"]],["self"]]],[11,"from","","",57,[[["cow",["str"]]],["self"]]],[11,"from","","",57,[[["string"]],["self"]]],[11,"from","","",57,[[["usize"]],["self"]]],[11,"as_ref","","",57,[[["self"]],["str"]]],[11,"fmt","","",57,[[["self"],["formatter"]],["result",["error"]]]],[11,"eq","","",57,[[["self"],["t"]],["bool"]]],[11,"to_tokens","","",39,[[["self"],["tokens"]]]],[11,"fmt","","",38,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",37,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",39,[[["self"],["formatter"]],["result"]]],[11,"clone","","",39,[[["self"]],["lit"]]],[11,"eq","","",39,[[["self"],["lit"]],["bool"]]],[11,"ne","","",39,[[["self"],["lit"]],["bool"]]],[11,"hash","","",39,N],[11,"fmt","","",40,[[["self"],["formatter"]],["result"]]],[11,"clone","","",40,[[["self"]],["strstyle"]]],[11,"eq","","",40,[[["self"],["strstyle"]],["bool"]]],[11,"ne","","",40,[[["self"],["strstyle"]],["bool"]]],[11,"hash","","",40,N],[11,"from","","",39,[[["string"]],["lit"]]],[11,"from","","",39,[[["str"]],["lit"]]],[11,"from","","",39,[[["vec",["u8"]]],["lit"]]],[11,"from","","",39,N],[11,"from","","",39,[[["char"]],["lit"]]],[11,"from","","",39,[[["bool"]],["lit"]]],[11,"fmt","","",38,[[["self"],["formatter"]],["result"]]],[11,"clone","","",38,[[["self"]],["intty"]]],[11,"eq","","",38,[[["self"],["intty"]],["bool"]]],[11,"hash","","",38,N],[11,"fmt","","",37,[[["self"],["formatter"]],["result"]]],[11,"clone","","",37,[[["self"]],["floatty"]]],[11,"eq","","",37,[[["self"],["floatty"]],["bool"]]],[11,"hash","","",37,N],[11,"from","","",39,[[["isize"]],["lit"]]],[11,"from","","",39,[[["i8"]],["lit"]]],[11,"from","","",39,[[["i16"]],["lit"]]],[11,"from","","",39,[[["i32"]],["lit"]]],[11,"from","","",39,[[["i64"]],["lit"]]],[11,"from","","",39,[[["usize"]],["lit"]]],[11,"from","","",39,[[["u8"]],["lit"]]],[11,"from","","",39,[[["u16"]],["lit"]]],[11,"from","","",39,[[["u32"]],["lit"]]],[11,"from","","",39,[[["u64"]],["lit"]]],[11,"from","","",39,[[["f32"]],["lit"]]],[11,"from","","",39,[[["f64"]],["lit"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"clone","","",14,[[["self"]],["strlit"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"clone","","",11,[[["self"]],["bytestrlit"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"clone","","",13,[[["self"]],["intlit"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"clone","","",12,[[["self"]],["floatlit"]]],[11,"to_tokens","","",16,[[["self"],["tokens"]]]],[11,"to_tokens","","",44,[[["self"],["tokens"]]]],[11,"to_tokens","","",15,[[["self"],["tokens"]]]],[11,"to_tokens","","",43,[[["self"],["tokens"]]]],[11,"to_tokens","","",41,[[["self"],["tokens"]]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"clone","","",16,[[["self"]],["mac"]]],[11,"eq","","",16,[[["self"],["mac"]],["bool"]]],[11,"ne","","",16,[[["self"],["mac"]],["bool"]]],[11,"hash","","",16,N],[11,"fmt","","",44,[[["self"],["formatter"]],["result"]]],[11,"clone","","",44,[[["self"]],["tokentree"]]],[11,"eq","","",44,[[["self"],["tokentree"]],["bool"]]],[11,"ne","","",44,[[["self"],["tokentree"]],["bool"]]],[11,"hash","","",44,N],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"clone","","",15,[[["self"]],["delimited"]]],[11,"eq","","",15,[[["self"],["delimited"]],["bool"]]],[11,"ne","","",15,[[["self"],["delimited"]],["bool"]]],[11,"hash","","",15,N],[11,"fmt","","",43,[[["self"],["formatter"]],["result"]]],[11,"clone","","",43,[[["self"]],["token"]]],[11,"eq","","",43,[[["self"],["token"]],["bool"]]],[11,"ne","","",43,[[["self"],["token"]],["bool"]]],[11,"hash","","",43,N],[11,"fmt","","",41,[[["self"],["formatter"]],["result"]]],[11,"clone","","",41,[[["self"]],["binoptoken"]]],[11,"eq","","",41,[[["self"],["binoptoken"]],["bool"]]],[11,"hash","","",41,N],[11,"fmt","","",42,[[["self"],["formatter"]],["result"]]],[11,"clone","","",42,[[["self"]],["delimtoken"]]],[11,"eq","","",42,[[["self"],["delimtoken"]],["bool"]]],[11,"hash","","",42,N],[11,"to_tokens","","",17,[[["self"],["tokens"]]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"clone","","",17,[[["self"]],["deriveinput"]]],[11,"eq","","",17,[[["self"],["deriveinput"]],["bool"]]],[11,"ne","","",17,[[["self"],["deriveinput"]],["bool"]]],[11,"hash","","",17,N],[11,"fmt","","",45,[[["self"],["formatter"]],["result"]]],[11,"clone","","",45,[[["self"]],["body"]]],[11,"eq","","",45,[[["self"],["body"]],["bool"]]],[11,"ne","","",45,[[["self"],["body"]],["bool"]]],[11,"hash","","",45,N],[11,"op","","",46,[[["self"]],["str"]]],[11,"assign_op","","",46,[[["self"]],["option",["str"]]]],[11,"to_tokens","","",46,[[["self"],["tokens"]]]],[11,"op","","",47,[[["self"]],["str"]]],[11,"to_tokens","","",47,[[["self"],["tokens"]]]],[11,"fmt","","",46,[[["self"],["formatter"]],["result"]]],[11,"clone","","",46,[[["self"]],["binop"]]],[11,"eq","","",46,[[["self"],["binop"]],["bool"]]],[11,"hash","","",46,N],[11,"fmt","","",47,[[["self"],["formatter"]],["result"]]],[11,"clone","","",47,[[["self"]],["unop"]]],[11,"eq","","",47,[[["self"],["unop"]],["bool"]]],[11,"hash","","",47,N],[11,"to_tokens","","",52,[[["self"],["tokens"]]]],[11,"to_tokens","","",50,[[["self"],["tokens"]]]],[11,"to_tokens","","",23,[[["self"],["tokens"]]]],[11,"to_tokens","","",24,[[["self"],["tokens"]]]],[11,"to_tokens","","",51,[[["self"],["tokens"]]]],[11,"to_tokens","","",18,[[["self"],["tokens"]]]],[11,"to_tokens","","",27,[[["self"],["tokens"]]]],[11,"to_tokens","","",22,[[["self"],["tokens"]]]],[11,"to_tokens","","",25,[[["self"],["tokens"]]]],[11,"to_tokens","","",20,[[["self"],["tokens"]]]],[11,"to_tokens","","",19,[[["self"],["tokens"]]]],[11,"to_tokens","","",53,[[["self"],["tokens"]]]],[11,"to_tokens","","",48,[[["self"],["tokens"]]]],[11,"fmt","","",52,[[["self"],["formatter"]],["result"]]],[11,"clone","","",52,[[["self"]],["ty"]]],[11,"eq","","",52,[[["self"],["ty"]],["bool"]]],[11,"ne","","",52,[[["self"],["ty"]],["bool"]]],[11,"hash","","",52,N],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"clone","","",21,[[["self"]],["mutty"]]],[11,"eq","","",21,[[["self"],["mutty"]],["bool"]]],[11,"ne","","",21,[[["self"],["mutty"]],["bool"]]],[11,"hash","","",21,N],[11,"fmt","","",50,[[["self"],["formatter"]],["result"]]],[11,"clone","","",50,[[["self"]],["mutability"]]],[11,"eq","","",50,[[["self"],["mutability"]],["bool"]]],[11,"hash","","",50,N],[11,"fmt","","",23,[[["self"],["formatter"]],["result"]]],[11,"clone","","",23,[[["self"]],["path"]]],[11,"eq","","",23,[[["self"],["path"]],["bool"]]],[11,"ne","","",23,[[["self"],["path"]],["bool"]]],[11,"hash","","",23,N],[11,"from","","",23,[[["t"]],["self"]]],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"clone","","",24,[[["self"]],["pathsegment"]]],[11,"eq","","",24,[[["self"],["pathsegment"]],["bool"]]],[11,"ne","","",24,[[["self"],["pathsegment"]],["bool"]]],[11,"hash","","",24,N],[11,"from","","",24,[[["t"]],["self"]]],[11,"fmt","","",51,[[["self"],["formatter"]],["result"]]],[11,"clone","","",51,[[["self"]],["pathparameters"]]],[11,"eq","","",51,[[["self"],["pathparameters"]],["bool"]]],[11,"ne","","",51,[[["self"],["pathparameters"]],["bool"]]],[11,"hash","","",51,N],[11,"none","","",51,[[],["self"]]],[11,"is_empty","","",51,[[["self"]],["bool"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"clone","","",18,[[["self"]],["anglebracketedparameterdata"]]],[11,"eq","","",18,[[["self"],["anglebracketedparameterdata"]],["bool"]]],[11,"ne","","",18,[[["self"],["anglebracketedparameterdata"]],["bool"]]],[11,"default","","",18,[[],["anglebracketedparameterdata"]]],[11,"hash","","",18,N],[11,"fmt","","",27,[[["self"],["formatter"]],["result"]]],[11,"clone","","",27,[[["self"]],["typebinding"]]],[11,"eq","","",27,[[["self"],["typebinding"]],["bool"]]],[11,"ne","","",27,[[["self"],["typebinding"]],["bool"]]],[11,"hash","","",27,N],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"clone","","",22,[[["self"]],["parenthesizedparameterdata"]]],[11,"eq","","",22,[[["self"],["parenthesizedparameterdata"]],["bool"]]],[11,"ne","","",22,[[["self"],["parenthesizedparameterdata"]],["bool"]]],[11,"hash","","",22,N],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"clone","","",25,[[["self"]],["polytraitref"]]],[11,"eq","","",25,[[["self"],["polytraitref"]],["bool"]]],[11,"ne","","",25,[[["self"],["polytraitref"]],["bool"]]],[11,"hash","","",25,N],[11,"fmt","","",26,[[["self"],["formatter"]],["result"]]],[11,"clone","","",26,[[["self"]],["qself"]]],[11,"eq","","",26,[[["self"],["qself"]],["bool"]]],[11,"ne","","",26,[[["self"],["qself"]],["bool"]]],[11,"hash","","",26,N],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"clone","","",20,[[["self"]],["barefnty"]]],[11,"eq","","",20,[[["self"],["barefnty"]],["bool"]]],[11,"ne","","",20,[[["self"],["barefnty"]],["bool"]]],[11,"hash","","",20,N],[11,"fmt","","",53,[[["self"],["formatter"]],["result"]]],[11,"clone","","",53,[[["self"]],["unsafety"]]],[11,"eq","","",53,[[["self"],["unsafety"]],["bool"]]],[11,"hash","","",53,N],[11,"fmt","","",48,[[["self"],["formatter"]],["result"]]],[11,"clone","","",48,[[["self"]],["abi"]]],[11,"eq","","",48,[[["self"],["abi"]],["bool"]]],[11,"ne","","",48,[[["self"],["abi"]],["bool"]]],[11,"hash","","",48,N],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"clone","","",19,[[["self"]],["barefnarg"]]],[11,"eq","","",19,[[["self"],["barefnarg"]],["bool"]]],[11,"ne","","",19,[[["self"],["barefnarg"]],["bool"]]],[11,"hash","","",19,N],[11,"fmt","","",49,[[["self"],["formatter"]],["result"]]],[11,"clone","","",49,[[["self"]],["functionretty"]]],[11,"eq","","",49,[[["self"],["functionretty"]],["bool"]]],[11,"ne","","",49,[[["self"],["functionretty"]],["bool"]]],[11,"hash","","",49,N],[0,"parse","","This module contains a set of exported nom parsers which can be used to parse custom grammars when used alongside the `synom` crate.",N,N],[4,"IResult","syn::parse","The result of a parser.",N,N],[13,"Done","","Parsing succeeded. The first field contains the rest of the unparsed data and the second field contains the parse result.",58,N],[13,"Error","","Parsing failed.",58,N],[5,"lit","","",N,[[["str"]],["iresult",["str","lit"]]]],[5,"string","","",N,[[["str"]],["iresult",["str","strlit"]]]],[5,"byte_string","","",N,[[["str"]],["iresult",["str","bytestrlit"]]]],[5,"byte","","",N,[[["str"]],["iresult",["str","u8"]]]],[5,"character","","",N,[[["str"]],["iresult",["str","char"]]]],[5,"float","","",N,[[["str"]],["iresult",["str","floatlit"]]]],[5,"int","","",N,[[["str"]],["iresult",["str","intlit"]]]],[5,"boolean","","",N,[[["str"]],["iresult",["str","bool"]]]],[5,"ty","","",N,[[["str"]],["iresult",["str","ty"]]]],[5,"path","","",N,[[["str"]],["iresult",["str","path"]]]],[5,"tt","","",N,[[["str"]],["iresult",["str","tokentree"]]]],[5,"ident","","",N,[[["str"]],["iresult",["str","ident"]]]],[5,"lifetime","","",N,[[["str"]],["iresult",["str","lifetime"]]]],[11,"expect","","Unwraps the result, asserting the the parse is complete. Panics with a message based on the given string if the parse failed or is incomplete.",58,[[["self"],["str"]],["o"]]],[11,"eq","","",58,[[["self"],["iresult"]],["bool"]]],[11,"ne","","",58,[[["self"],["iresult"]],["bool"]]],[11,"clone","","",58,[[["self"]],["iresult"]]],[11,"fmt","","",58,[[["self"],["formatter"]],["result",["error"]]]]],"paths":[[3,"Attribute"],[3,"Field"],[3,"Variant"],[3,"Generics"],[3,"Lifetime"],[3,"LifetimeDef"],[3,"TyParam"],[3,"WhereBoundPredicate"],[3,"WhereClause"],[3,"WhereEqPredicate"],[3,"WhereRegionPredicate"],[3,"ByteStrLit"],[3,"FloatLit"],[3,"IntLit"],[3,"StrLit"],[3,"Delimited"],[3,"Mac"],[3,"DeriveInput"],[3,"AngleBracketedParameterData"],[3,"BareFnArg"],[3,"BareFnTy"],[3,"MutTy"],[3,"ParenthesizedParameterData"],[3,"Path"],[3,"PathSegment"],[3,"PolyTraitRef"],[3,"QSelf"],[3,"TypeBinding"],[4,"AttrStyle"],[4,"MetaItem"],[4,"NestedMetaItem"],[4,"ConstExpr"],[4,"VariantData"],[4,"Visibility"],[4,"TraitBoundModifier"],[4,"TyParamBound"],[4,"WherePredicate"],[4,"FloatTy"],[4,"IntTy"],[4,"Lit"],[4,"StrStyle"],[4,"BinOpToken"],[4,"DelimToken"],[4,"Token"],[4,"TokenTree"],[4,"Body"],[4,"BinOp"],[4,"UnOp"],[4,"Abi"],[4,"FunctionRetTy"],[4,"Mutability"],[4,"PathParameters"],[4,"Ty"],[4,"Unsafety"],[3,"ImplGenerics"],[3,"TyGenerics"],[3,"Turbofish"],[3,"Ident"],[4,"IResult"]]};
searchIndex["synom"]={"doc":"Adapted from `nom` by removing the `IResult::Incomplete` variant which:","items":[[4,"IResult","synom","The result of a parser.",N,N],[13,"Done","","Parsing succeeded. The first field contains the rest of the unparsed data and the second field contains the parse result.",0,N],[13,"Error","","Parsing failed.",0,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"eq","","",0,[[["self"],["iresult"]],["bool"]]],[11,"ne","","",0,[[["self"],["iresult"]],["bool"]]],[11,"clone","","",0,[[["self"]],["iresult"]]],[11,"expect","","Unwraps the result, asserting the the parse is complete. Panics with a message based on the given string if the parse failed or is incomplete.",0,[[["self"],["str"]],["o"]]],[14,"punct","","Parse a piece of punctuation like \"+\" or \"+=\".",N,N],[14,"keyword","","Parse a keyword like \"fn\" or \"struct\".",N,N],[14,"option","","Turn a failed parse into `None` and a successful parse into `Some`.",N,N],[14,"opt_vec","","Turn a failed parse into an empty vector. The argument parser must itself return a vector.",N,N],[14,"epsilon","","Parses nothing and always succeeds.",N,N],[14,"separated_list","","Zero or more values separated by some separator. Does not allow a trailing seperator.",N,N],[14,"terminated_list","","Zero or more values separated by some separator. A trailing separator is allowed.",N,N],[14,"named","","Define a function from a parser combination.",N,N],[14,"call","","Invoke the given parser function with the passed in arguments.",N,N],[14,"map","","Transform the result of a parser by applying a function or closure.",N,N],[14,"not","","Parses successfully if the given parser fails to parse. Does not consume any of the input.",N,N],[14,"cond","","Conditionally execute the given parser.",N,N],[14,"cond_reduce","","Fail to parse if condition is false, otherwise parse the given parser.",N,N],[14,"preceded","","Parse two things, returning the value of the second.",N,N],[14,"terminated","","Parse two things, returning the value of the first.",N,N],[14,"many0","","Parse zero or more values using the given parser.",N,N],[14,"peek","","Parse a value without consuming it from the input data.",N,N],[14,"take_until","","Parse the part of the input up to but not including the given string. Fail to parse if the given string is not present in the input.",N,N],[14,"tag","","Parse the given string from exactly the current position in the input. You almost always want `punct!` or `keyword!` instead of this.",N,N],[14,"switch","","Pattern-match the result of a parser to select which other parser to run.",N,N],[14,"value","","Produce the given value without parsing anything. Useful as an argument to `switch!`.",N,N],[14,"delimited","","Value surrounded by a pair of delimiters.",N,N],[14,"separated_nonempty_list","","One or more values separated by some separator. Does not allow a trailing separator.",N,N],[14,"tuple","","Run a series of parsers and produce all of the results in a tuple.",N,N],[14,"alt","","Run a series of parsers, returning the result of the first one which succeeds.",N,N],[14,"do_parse","","Run a series of parsers, one after another, optionally assigning the results a name. Fail if any of the parsers fails.",N,N]],"paths":[[4,"IResult"]]};
searchIndex["unicode_xid"]={"doc":"Determine if a `char` is a valid identifier for a parser and/or lexer according to Unicode Standard Annex #31 rules.","items":[[17,"UNICODE_VERSION","unicode_xid","The version of Unicode that this version of unicode-xid is based on.",N,N],[8,"UnicodeXID","","Methods for determining if a character is a valid identifier character.",N,N],[10,"is_xid_start","","Returns whether the specified character satisfies the 'XID_Start' Unicode property.",0,[[["self"]],["bool"]]],[10,"is_xid_continue","","Returns whether the specified `char` satisfies the 'XID_Continue' Unicode property.",0,[[["self"]],["bool"]]]],"paths":[[8,"UnicodeXID"]]};
initSearch(searchIndex);
